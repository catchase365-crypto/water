<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>深海 - 终极控制版</title>
    <style>
        /* --- 基础样式 --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000508;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }

        /* --- 齿轮按钮 --- */
        #toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            z-index: 100;
            cursor: pointer;
            transition: transform 0.3s ease, background 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        #toggle-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.2);
        }

        /* --- 折叠面板 --- */
        #settings-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            max-height: 80vh; /* 防止太长超出屏幕 */
            overflow-y: auto;
            background: rgba(10, 15, 20, 0.85);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 20px;
            color: #eee;
            z-index: 99;
            transform-origin: top right;
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            opacity: 0;
            transform: scale(0.9) translateY(-20px);
            pointer-events: none; /* 隐藏时不挡点击 */
        }
        
        /* 展开状态 */
        #settings-panel.active {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }

        /* 面板内部组件 */
        .panel-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .panel-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: #00ccff;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        .control-label {
            font-size: 12px;
            color: #aaa;
            flex: 1;
        }
        .control-value {
            font-size: 12px;
            color: #fff;
            width: 30px;
            text-align: right;
            margin-left: 8px;
        }

        /* 滑块样式 */
        input[type="range"] {
            -webkit-appearance: none;
            width: 50%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            margin-top: -6px; /* 居中 */
        }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: transparent;
        }

        /* 颜色选择器 */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 40px;
            height: 24px;
            background: none;
            cursor: pointer;
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0; 
        }
        input[type="color"]::-webkit-color-swatch {
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px;
        }

        /* Loading */
        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.4);
            font-size: 12px;
            pointer-events: none;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <!-- 1. 切换按钮 -->
    <div id="toggle-btn">⚙️</div>

    <!-- 2. 设置面板 -->
    <div id="settings-panel">
        
        <!-- 主灯设置 -->
        <div class="panel-section">
            <div class="section-title">主光源 (Main Light)</div>
            <div class="control-row">
                <span class="control-label">水平位置</span>
                <input type="range" id="main-x" min="-100" max="100" value="20">
            </div>
            <div class="control-row">
                <span class="control-label">垂直高度</span>
                <input type="range" id="main-y" min="10" max="100" value="40">
            </div>
            <div class="control-row">
                <span class="control-label">亮度</span>
                <input type="range" id="main-int" min="0" max="3" step="0.1" value="1.0">
            </div>
        </div>

        <!-- 副灯设置 -->
        <div class="panel-section">
            <div class="section-title">副灯 (Point Light)</div>
            <div class="control-row">
                <span class="control-label">中心偏移</span>
                <input type="range" id="point-x" min="-50" max="50" value="0">
            </div>
            <div class="control-row">
                <span class="control-label">悬浮高度</span>
                <input type="range" id="point-y" min="5" max="60" value="20">
            </div>
            <div class="control-row">
                <span class="control-label">亮度</span>
                <input type="range" id="point-int" min="0" max="2" step="0.1" value="0.6">
            </div>
        </div>

        <!-- 水面设置 -->
        <div class="panel-section">
            <div class="section-title">水面属性 (Water)</div>
            <div class="control-row">
                <span class="control-label">水体颜色</span>
                <input type="color" id="water-color" value="#004466">
            </div>
            <div class="control-row">
                <span class="control-label">涟漪力度</span>
                <input type="range" id="ripple-str" min="1" max="10" step="0.5" value="5">
            </div>
            <div class="control-row">
                <span class="control-label">环境底光</span>
                <input type="range" id="ambient-int" min="0" max="1.5" step="0.1" value="0.6">
            </div>
        </div>
        
        <div style="text-align:center; font-size:10px; color:#555;">
            点击面板外任意区域收起
        </div>
    </div>

    <div id="loader">INITIALIZING...</div>
    <div id="canvas-container"></div>

    <!-- 引用 Three.js -->
    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ==========================================
        //        核心全局对象 (App State)
        // ==========================================
        let app = {
            scene: null, camera: null, renderer: null,
            mesh: null,
            dirLight: null, pointLight: null, ambientLight: null,
            animationId: null,
            particles: [],
            buffers: { current: null, previous: null },
            config: {
                dragStrength: -5.0,
                color: 0x004466
            }
        };

        const SYSTEM = { gridSize: 60, damping: 0.965, planeSize: 300 };
        
        // 交互变量
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDragging = false;
        
        // 事件函数引用(用于清理)
        let listeners = {};

        // 初始化入口
        window.addEventListener('load', initApp);

        // UI 逻辑：切换面板
        const toggleBtn = document.getElementById('toggle-btn');
        const panel = document.getElementById('settings-panel');
        let isPanelOpen = false;

        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // 防止点按钮时触发水波
            togglePanel();
        });

        // 阻止面板上的点击事件传递到 Canvas (防止调节参数时误触水波)
        panel.addEventListener('mousedown', (e) => e.stopPropagation());
        panel.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: false });
        panel.addEventListener('touchmove', (e) => e.stopPropagation(), { passive: false });

        // 点击画布关闭面板
        document.addEventListener('click', (e) => {
            if (isPanelOpen && e.target.id !== 'toggle-btn' && !panel.contains(e.target)) {
                togglePanel();
            }
        });

        function togglePanel() {
            isPanelOpen = !isPanelOpen;
            if (isPanelOpen) {
                panel.classList.add('active');
            } else {
                panel.classList.remove('active');
            }
        }

        // ==========================================
        //        清理与初始化 (稳定性核心)
        // ==========================================
        function cleanup() {
            if (app.animationId) cancelAnimationFrame(app.animationId);
            
            // 清理 Three.js 对象
            if (app.scene) {
                app.scene.traverse((obj) => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                        else obj.material.dispose();
                    }
                });
            }
            if (app.renderer) {
                app.renderer.dispose();
                app.renderer.forceContextLoss();
            }

            // 清理 DOM
            const container = document.getElementById('canvas-container');
            if (container) container.innerHTML = ''; // 清空 canvas

            // 移除旧监听器
            if (listeners.resize) window.removeEventListener('resize', listeners.resize);
            // ...其他监听器在 init 时重新绑定新的，旧的随 DOM 销毁自动失效或被覆盖
            
            app = { ...app, scene: null, camera: null, renderer: null, particles: [] };
        }

        function initApp() {
            cleanup();
            setTimeout(() => {
                initThree();
                initUIBinding(); // 绑定 UI 控件到新的 Three 对象
                animate();
                document.getElementById('loader').style.opacity = '0';
            }, 50);
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            
            // 1. 场景
            app.scene = new THREE.Scene();
            app.scene.background = new THREE.Color(0x000508);
            app.scene.fog = new THREE.FogExp2(0x000508, 0.008);

            // 2. 相机 (保持用户喜欢的 100 高度)
            app.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
            app.camera.position.set(0, 100, 60);
            app.camera.lookAt(0, 0, -20);

            // 3. 渲染器
            app.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            app.renderer.setSize(window.innerWidth, window.innerHeight);
            app.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(app.renderer.domElement);

            // 4. 灯光 (保存引用以便 UI 控制)
            app.ambientLight = new THREE.AmbientLight(0x406080, 0.6); // 默认 0.6
            app.scene.add(app.ambientLight);

            app.dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            app.dirLight.position.set(20, 40, -20); // 默认位置
            app.scene.add(app.dirLight);

            app.pointLight = new THREE.PointLight(0x00ffff, 0.6, 100);
            app.pointLight.position.set(0, 20, 0); // 默认位置
            app.scene.add(app.pointLight);

            // 5. 水面
            const cols = SYSTEM.gridSize;
            const rows = SYSTEM.gridSize;
            const geometry = new THREE.PlaneGeometry(SYSTEM.planeSize, SYSTEM.planeSize, cols - 1, rows - 1);
            const material = new THREE.MeshPhongMaterial({
                color: app.config.color,
                emissive: 0x000510,
                specular: 0x88ccff,
                shininess: 90,
                side: THREE.DoubleSide,
                flatShading: false
            });

            app.mesh = new THREE.Mesh(geometry, material);
            app.mesh.rotation.x = -Math.PI / 2;
            app.scene.add(app.mesh);

            // 6. 缓冲区
            const count = cols * rows;
            app.buffers.current = new Float32Array(count).fill(0);
            app.buffers.previous = new Float32Array(count).fill(0);

            // 7. 事件绑定
            listeners.resize = () => {
                app.camera.aspect = window.innerWidth / window.innerHeight;
                app.camera.updateProjectionMatrix();
                app.renderer.setSize(window.innerWidth, window.innerHeight);
            };
            window.addEventListener('resize', listeners.resize);

            // 交互事件
            const start = (x, y) => { isDragging = true; interact(x, y); };
            const move = (x, y) => { if(isDragging) interact(x, y); };
            const end = () => { isDragging = false; };

            container.addEventListener('mousedown', (e) => start(e.clientX, e.clientY));
            window.addEventListener('mouseup', end);
            container.addEventListener('mousemove', (e) => move(e.clientX, e.clientY));

            container.addEventListener('touchstart', (e) => {
                // 如果触摸点在面板上，不触发水波(虽然有 stopPropagation，双重保险)
                if(e.target.closest('#settings-panel')) return;
                start(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }, { passive: false });
            window.addEventListener('touchend', end);
            container.addEventListener('touchmove', (e) => move(e.changedTouches[0].clientX, e.changedTouches[0].clientY), { passive: false });
            
            // 开场涟漪
            setTimeout(()=>triggerRipple(Math.floor(cols/2), Math.floor(rows/2)), 500);
        }

        // ==========================================
        //        UI 绑定逻辑 (核心新增)
        // ==========================================
        function initUIBinding() {
            // 辅助函数
            const bind = (id, callback) => {
                const el = document.getElementById(id);
                // 移除旧监听防止累积 (简单做法：克隆节点替换)
                const newEl = el.cloneNode(true);
                el.parentNode.replaceChild(newEl, el);
                newEl.addEventListener('input', (e) => callback(e.target.value));
            };

            // 1. 主灯控制
            bind('main-x', (v) => app.dirLight.position.x = parseFloat(v));
            bind('main-y', (v) => app.dirLight.position.y = parseFloat(v));
            bind('main-int', (v) => app.dirLight.intensity = parseFloat(v));

            // 2. 副灯控制
            bind('point-x', (v) => app.pointLight.position.x = parseFloat(v)); // 只控制X轴偏移
            bind('point-y', (v) => app.pointLight.position.y = parseFloat(v));
            bind('point-int', (v) => app.pointLight.intensity = parseFloat(v));

            // 3. 水面控制
            bind('water-color', (v) => app.mesh.material.color.set(v));
            bind('ripple-str', (v) => app.config.dragStrength = -parseFloat(v)); // 注意负号
            bind('ambient-int', (v) => app.ambientLight.intensity = parseFloat(v));
        }

        // ==========================================
        //        物理与渲染
        // ==========================================
        function interact(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, app.camera);
            const intersects = raycaster.intersectObject(app.mesh);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const pSize = SYSTEM.planeSize;
                const cols = SYSTEM.gridSize;
                
                // 坐标映射
                const gridX = Math.floor(((point.x + pSize/2) / pSize) * cols);
                const gridY = Math.floor(((point.z + pSize/2) / pSize) * cols);
                
                triggerRipple(gridX, gridY);
                if (Math.random() > 0.65) createSplash(point);
            }
        }

        function triggerRipple(x, y) {
            const cols = SYSTEM.gridSize;
            if (x >= 1 && x < cols - 1 && y >= 1 && y < cols - 1) {
                const index = y * cols + x;
                const str = app.config.dragStrength;
                
                app.buffers.previous[index] += str * 5;
                app.buffers.previous[index-1] += str * 2;
                app.buffers.previous[index+1] += str * 2;
                app.buffers.previous[index-cols] += str * 2;
                app.buffers.previous[index+cols] += str * 2;
            }
        }

        function createSplash(pos) {
            const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const mat = new THREE.MeshBasicMaterial({ color: 0xaaccff, transparent: true, opacity: 0.7 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.position.y = Math.random() * 0.5 + 0.2;
            
            const vel = new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.6+0.2, (Math.random()-0.5)*0.5);
            app.scene.add(mesh);
            app.particles.push({ mesh, vel, life: 1.0 });
        }

        function updateWater() {
            const cols = SYSTEM.gridSize;
            const count = cols * cols;
            // 简单波动方程
            for (let i = 1; i < cols - 1; i++) {
                for (let j = 1; j < cols - 1; j++) {
                    const idx = j * cols + i;
                    const val = (
                        app.buffers.previous[idx-1] + app.buffers.previous[idx+1] +
                        app.buffers.previous[idx-cols] + app.buffers.previous[idx+cols]
                    ) / 2 - app.buffers.current[idx];
                    app.buffers.current[idx] = val * SYSTEM.damping;
                }
            }
            
            const positions = app.mesh.geometry.attributes.position.array;
            for (let i = 0; i < count; i++) positions[i*3+2] = app.buffers.current[i];
            app.mesh.geometry.attributes.position.needsUpdate = true;
            app.mesh.geometry.computeVertexNormals();

            let temp = app.buffers.previous;
            app.buffers.previous = app.buffers.current;
            app.buffers.current = temp;
        }

        function updateParticles() {
            for (let i = app.particles.length - 1; i >= 0; i--) {
                let p = app.particles[i];
                p.vel.y -= 0.04;
                p.mesh.position.add(p.vel);
                p.life -= 0.03;
                p.mesh.rotation.x += 0.2;
                p.mesh.scale.setScalar(p.life);
                if (p.life <= 0 || p.mesh.position.y < -2) {
                    app.scene.remove(p.mesh);
                    if(p.mesh.geometry) p.mesh.geometry.dispose();
                    if(p.mesh.material) p.mesh.material.dispose();
                    app.particles.splice(i, 1);
                }
            }
        }

        function animate() {
            app.animationId = requestAnimationFrame(animate);
            updateWater();
            updateParticles();
            if(app.renderer && app.scene && app.camera) {
                app.renderer.render(app.scene, app.camera);
            }
        }
    </script>
</body>
</html>

