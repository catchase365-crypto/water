<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>æ·±æµ· - ç»ˆæå…¨æ§ç‰ˆ</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000508;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }

        /* --- é½¿è½®æŒ‰é’® --- */
        #toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 44px;
            height: 44px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            z-index: 100;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }
        #toggle-btn:active { transform: scale(0.9); }

        /* --- è¶…çº§æ§åˆ¶é¢æ¿ --- */
        #settings-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 320px; /* åŠ å®½ä»¥å®¹çº³æ›´å¤šå†…å®¹ */
            max-height: 85vh; /* å…è®¸æ»šåŠ¨ */
            overflow-y: auto;
            background: rgba(8, 12, 16, 0.92); /* åŠ æ·±èƒŒæ™¯ */
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 15px;
            color: #eee;
            z-index: 99;
            transform-origin: top right;
            transition: all 0.3s cubic-bezier(0.19, 1, 0.22, 1);
            opacity: 0;
            transform: scale(0.95) translateY(-20px);
            pointer-events: none;
            /* æ»šåŠ¨æ¡æ ·å¼ */
            scrollbar-width: thin;
            scrollbar-color: #00ccff rgba(0,0,0,0.3);
        }
        #settings-panel::-webkit-scrollbar {
            width: 6px;
        }
        #settings-panel::-webkit-scrollbar-thumb {
            background-color: #00ccff;
            border-radius: 3px;
        }
        
        #settings-panel.active {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }

        .panel-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .section-title {
            font-size: 13px;
            font-weight: 700;
            color: #00ccff;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
        }
        .section-title::before {
            content: '';
            display: inline-block;
            width: 4px;
            height: 12px;
            background: #00ccff;
            margin-right: 8px;
            border-radius: 2px;
        }
        
        /* æ¨¡å¼åˆ‡æ¢æŒ‰é’®ç»„ */
        .mode-group {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .mode-btn {
            flex: 1;
            padding: 10px;
            font-size: 12px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        .mode-btn.active {
            background: rgba(0, 204, 255, 0.25);
            border-color: #00ccff;
            color: #fff;
            box-shadow: 0 0 12px rgba(0,204,255,0.2);
            font-weight: bold;
        }

        .clear-btn {
            width: 100%;
            padding: 8px;
            background: rgba(255, 60, 60, 0.15);
            border: 1px solid rgba(255, 60, 60, 0.3);
            color: #ffcccc;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .clear-btn:active { background: rgba(255, 60, 60, 0.3); }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        .control-label { font-size: 12px; color: #ccc; flex: 1; }
        
        input[type="range"] {
            -webkit-appearance: none;
            width: 55%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #eee;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 40px;
            height: 24px;
            background: none;
            cursor: pointer;
        }

        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            pointer-events: none;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="toggle-btn">âš™ï¸</div>

    <div id="settings-panel">
        <!-- 1. äº¤äº’ä¸æ¨¡å¼ -->
        <div class="panel-section">
            <div class="section-title">äº¤äº’æ¨¡å¼</div>
            <div class="mode-group">
                <div class="mode-btn active" onclick="setMode('ripple')" id="btn-ripple">ğŸŒŠ çº¯å‡€æ¶Ÿæ¼ª</div>
                <div class="mode-btn" onclick="setMode('confetti')" id="btn-confetti">ğŸ‰ æ’’å½©å¸¦</div>
            </div>
            <button class="clear-btn" onclick="clearFloatingItems()">ğŸ§¹ æ¸…é™¤æ‰€æœ‰æ¼‚æµ®ç‰©</button>
        </div>

        <!-- 2. ä¸»ç¯å…‰ -->
        <div class="panel-section">
            <div class="section-title">ä¸»å…‰æº (Main Light)</div>
            <div class="control-row">
                <span class="control-label">æ°´å¹³ä½ç½® X</span>
                <input type="range" id="main-x" min="-100" max="100" value="20">
            </div>
            <div class="control-row">
                <span class="control-label">å‚ç›´é«˜åº¦ Y</span>
                <input type="range" id="main-y" min="5" max="100" value="40">
            </div>
            <div class="control-row">
                <span class="control-label">å…‰ç…§å¼ºåº¦</span>
                <input type="range" id="main-int" min="0" max="3" step="0.1" value="1.0">
            </div>
        </div>

        <!-- 3. å‰¯ç¯å…‰ (æ‰¾å›æ¥äº†!) -->
        <div class="panel-section">
            <div class="section-title">ç‚¹å…‰æº (Point Light)</div>
            <div class="control-row">
                <span class="control-label">æ°´å¹³åç§» X</span>
                <input type="range" id="point-x" min="-60" max="60" value="0">
            </div>
            <div class="control-row">
                <span class="control-label">æ‚¬æµ®é«˜åº¦ Y</span>
                <input type="range" id="point-y" min="5" max="80" value="20">
            </div>
            <div class="control-row">
                <span class="control-label">å…‰ç…§å¼ºåº¦</span>
                <input type="range" id="point-int" min="0" max="2" step="0.1" value="0.6">
            </div>
        </div>

        <!-- 4. ç¯å¢ƒä¸ç‰©ç† -->
        <div class="panel-section">
            <div class="section-title">ç¯å¢ƒä¸æ°´ä½“</div>
            <div class="control-row">
                <span class="control-label">ç¯å¢ƒå…‰äº®åº¦</span>
                <input type="range" id="ambient-int" min="0" max="1.5" step="0.1" value="0.6">
            </div>
            <div class="control-row">
                <span class="control-label">æ°´ä½“é¢œè‰²</span>
                <input type="color" id="water-color" value="#004466">
            </div>
            <div class="control-row">
                <span class="control-label">æ¶Ÿæ¼ªæ‰©æ•£åŠ›åº¦</span>
                <input type="range" id="ripple-str" min="1" max="10" step="0.5" value="5">
            </div>
            <div class="control-row">
                <span class="control-label">è§†é‡ç¼©æ”¾ (Zoom)</span>
                <input type="range" id="cam-zoom" min="40" max="200" value="100">
            </div>
        </div>
        
        <div style="text-align:center; font-size:10px; color:#555; padding-bottom:5px;">
            ç‚¹å‡»é¢æ¿å¤–ä»»æ„åŒºåŸŸæ”¶èµ·
        </div>
    </div>

    <div id="loader">LOADING PHYSICS ENGINE...</div>
    <div id="canvas-container"></div>

    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ==========================================
        //        å…¨ å±€ çŠ¶ æ€
        // ==========================================
        let app = {
            scene: null, camera: null, renderer: null,
            mesh: null,
            dirLight: null, pointLight: null, ambientLight: null,
            animationId: null,
            particles: [],       
            floatingItems: [],   
            buffers: { current: null, previous: null },
            config: {
                dragStrength: -5.0,
                color: 0x004466,
                mode: 'ripple' 
            }
        };

        const SYSTEM = { gridSize: 60, damping: 0.965, planeSize: 300 };
        
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isDragging = false;
        
        // é²œè‰³çš„çº¸ç‰‡é¢œè‰²
        const CONFETTI_COLORS = [0xff3366, 0x00ff99, 0xffcc00, 0x00ccff, 0xffffff, 0xcc33ff];

        window.addEventListener('load', initApp);

        // ==========================================
        //        UI äº¤äº’ (ä¸å«ä¸šåŠ¡é€»è¾‘)
        // ==========================================
        const toggleBtn = document.getElementById('toggle-btn');
        const panel = document.getElementById('settings-panel');
        let isPanelOpen = false;

        toggleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            togglePanel();
        });

        panel.addEventListener('mousedown', (e) => e.stopPropagation());
        panel.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: false });
        panel.addEventListener('touchmove', (e) => e.stopPropagation(), { passive: false });

        document.addEventListener('click', (e) => {
            if (isPanelOpen && e.target.id !== 'toggle-btn' && !panel.contains(e.target)) {
                togglePanel();
            }
        });

        function togglePanel() {
            isPanelOpen = !isPanelOpen;
            panel.classList.toggle('active', isPanelOpen);
        }

        window.setMode = function(mode) {
            app.config.mode = mode;
            document.getElementById('btn-ripple').className = mode === 'ripple' ? 'mode-btn active' : 'mode-btn';
            document.getElementById('btn-confetti').className = mode === 'confetti' ? 'mode-btn active' : 'mode-btn';
        };

        window.clearFloatingItems = function() {
            app.floatingItems.forEach(item => {
                app.scene.remove(item.mesh);
                item.mesh.geometry.dispose();
                item.mesh.material.dispose();
            });
            app.floatingItems = [];
        };

        // ==========================================
        //        åˆ å§‹ åŒ–
        // ==========================================
        function cleanup() {
            if (app.animationId) cancelAnimationFrame(app.animationId);
            if (app.scene) {
                app.scene.traverse((obj) => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                        else obj.material.dispose();
                    }
                });
            }
            if (app.renderer) {
                app.renderer.dispose();
                app.renderer.forceContextLoss();
            }
            const container = document.getElementById('canvas-container');
            if (container) container.innerHTML = '';
            
            app.particles = [];
            app.floatingItems = [];
            app = { ...app, scene: null, camera: null, renderer: null };
        }

        function initApp() {
            cleanup();
            setTimeout(() => {
                initThree();
                initUIBinding();
                animate();
                document.getElementById('loader').style.opacity = '0';
            }, 50);
        }

        function initThree() {
            const container = document.getElementById('canvas-container');
            
            // åœºæ™¯
            app.scene = new THREE.Scene();
            app.scene.background = new THREE.Color(0x000508);
            app.scene.fog = new THREE.FogExp2(0x000508, 0.008);

            // ç›¸æœº
            app.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 2000);
            app.camera.position.set(0, 100, 60);
            app.camera.lookAt(0, 0, -20);

            // æ¸²æŸ“å™¨
            app.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            app.renderer.setSize(window.innerWidth, window.innerHeight);
            app.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            app.renderer.shadowMap.enabled = false; // æ€§èƒ½ä¼˜å…ˆ
            container.appendChild(app.renderer.domElement);

            // ç¯å…‰
            app.ambientLight = new THREE.AmbientLight(0x406080, 0.6);
            app.scene.add(app.ambientLight);

            app.dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            app.dirLight.position.set(20, 40, -20);
            app.scene.add(app.dirLight);

            app.pointLight = new THREE.PointLight(0x00ffff, 0.6, 100);
            app.pointLight.position.set(0, 20, 0);
            app.scene.add(app.pointLight);

            // æ°´é¢
            const cols = SYSTEM.gridSize;
            const rows = SYSTEM.gridSize;
            const geometry = new THREE.PlaneGeometry(SYSTEM.planeSize, SYSTEM.planeSize, cols - 1, rows - 1);
            const material = new THREE.MeshPhongMaterial({
                color: app.config.color,
                emissive: 0x000510,
                specular: 0x88ccff,
                shininess: 90,
                side: THREE.DoubleSide,
                flatShading: false
            });

            app.mesh = new THREE.Mesh(geometry, material);
            app.mesh.rotation.x = -Math.PI / 2;
            app.scene.add(app.mesh);

            // Buffer
            const count = cols * rows;
            app.buffers.current = new Float32Array(count).fill(0);
            app.buffers.previous = new Float32Array(count).fill(0);

            // Resize
            window.addEventListener('resize', () => {
                app.camera.aspect = window.innerWidth / window.innerHeight;
                app.camera.updateProjectionMatrix();
                app.renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // äº¤äº’
            const start = (x, y) => { isDragging = true; interact(x, y); };
            const move = (x, y) => { if(isDragging) interact(x, y); };
            const end = () => { isDragging = false; };

            container.addEventListener('mousedown', (e) => start(e.clientX, e.clientY));
            window.addEventListener('mouseup', end);
            container.addEventListener('mousemove', (e) => move(e.clientX, e.clientY));

            container.addEventListener('touchstart', (e) => {
                if(e.target.closest('#settings-panel')) return;
                start(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            }, { passive: false });
            window.addEventListener('touchend', end);
            container.addEventListener('touchmove', (e) => move(e.changedTouches[0].clientX, e.changedTouches[0].clientY), { passive: false });
            
            triggerRipple(Math.floor(cols/2), Math.floor(rows/2));
        }

        // ==========================================
        //        UI ç»‘å®š (æ¢å¤æ‰€æœ‰ Slider)
        // ==========================================
        function initUIBinding() {
            const bind = (id, fn) => {
                const el = document.getElementById(id);
                // å…‹éš†èŠ‚ç‚¹ä»¥ç§»é™¤æ—§ç›‘å¬å™¨
                const newEl = el.cloneNode(true);
                el.parentNode.replaceChild(newEl, el);
                newEl.addEventListener('input', (e) => fn(e.target.value));
            };

            // ä¸»ç¯
            bind('main-x', (v) => app.dirLight.position.x = parseFloat(v));
            bind('main-y', (v) => app.dirLight.position.y = parseFloat(v));
            bind('main-int', (v) => app.dirLight.intensity = parseFloat(v));

            // å‰¯ç¯ (Point)
            bind('point-x', (v) => app.pointLight.position.x = parseFloat(v));
            bind('point-y', (v) => app.pointLight.position.y = parseFloat(v));
            bind('point-int', (v) => app.pointLight.intensity = parseFloat(v));

            // ç¯å¢ƒä¸ç‰©ç†
            bind('ambient-int', (v) => app.ambientLight.intensity = parseFloat(v));
            bind('water-color', (v) => app.mesh.material.color.set(v));
            bind('ripple-str', (v) => app.config.dragStrength = -parseFloat(v));
            bind('cam-zoom', (v) => {
                // ä»…è°ƒæ•´é«˜åº¦ï¼Œä¿æŒæ³¨è§†ç‚¹ä¸å˜
                app.camera.position.y = parseFloat(v);
            });
        }

        // ==========================================
        //        ç‰©ç†äº¤äº’
        // ==========================================
        function interact(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, app.camera);
            const intersects = raycaster.intersectObject(app.mesh);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const pSize = SYSTEM.planeSize;
                const cols = SYSTEM.gridSize;
                
                const gridX = Math.floor(((point.x + pSize/2) / pSize) * cols);
                const gridY = Math.floor(((point.z + pSize/2) / pSize) * cols);
                triggerRipple(gridX, gridY);

                if (app.config.mode === 'confetti') {
                    if (Math.random() > 0.75) spawnConfetti(point);
                } else {
                    if (Math.random() > 0.7) createSplash(point);
                }
            }
        }

        function triggerRipple(x, y) {
            const cols = SYSTEM.gridSize;
            if (x >= 1 && x < cols - 1 && y >= 1 && y < cols - 1) {
                const index = y * cols + x;
                const str = app.config.dragStrength;
                
                app.buffers.previous[index] += str * 5;
                app.buffers.previous[index-1] += str * 2;
                app.buffers.previous[index+1] += str * 2;
                app.buffers.previous[index-cols] += str * 2;
                app.buffers.previous[index+cols] += str * 2;
            }
        }

        // ==========================================
        //        æ¼‚æµ®ç‰©ç³»ç»Ÿ (çœŸå®æµä½“ç‰©ç†)
        // ==========================================
        function spawnConfetti(pos) {
            const count = Math.floor(Math.random() * 2) + 1;
            
            for (let i = 0; i < count; i++) {
                // çº¸ç‰‡ç¨å¾®åšå¤§ä¸€ç‚¹ï¼Œåƒæ‚å¿—é¡µ
                const width = Math.random() * 2.5 + 1.0;
                const length = Math.random() * 3.5 + 1.5;
                const geo = new THREE.PlaneGeometry(width, length);
                
                const color = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
                const mat = new THREE.MeshPhongMaterial({ 
                    color: color, 
                    side: THREE.DoubleSide,
                    shininess: 50,
                    specular: 0x666666
                });

                const mesh = new THREE.Mesh(geo, mat);
                
                // åˆå§‹æ’’åœ¨æ°´é¢ä¸Šæ–¹ä¸€ç‚¹
                mesh.position.set(
                    pos.x + (Math.random()-0.5) * 4,
                    2, 
                    pos.z + (Math.random()-0.5) * 4
                );
                
                // éšæœºåˆå§‹æ—‹è½¬
                mesh.rotation.set(Math.random(), Math.random(), Math.random());

                app.scene.add(mesh);
                
                app.floatingItems.push({
                    mesh: mesh,
                    velocity: new THREE.Vector3(0, 0, 0), // åˆå§‹é™æ­¢ï¼Œç­‰æ°´æ¨
                    createdAt: Date.now()
                });
            }
            // é™åˆ¶æ•°é‡
            if (app.floatingItems.length > 60) {
                const item = app.floatingItems.shift();
                app.scene.remove(item.mesh);
                item.mesh.geometry.dispose();
                item.mesh.material.dispose();
            }
        }

        // åŒçº¿æ€§æ’å€¼è·å–ç²¾ç¡®é«˜åº¦ (æ ¸å¿ƒ)
        function getWaterHeightAt(x, z) {
            const pSize = SYSTEM.planeSize;
            const cols = SYSTEM.gridSize;
            
            // æ˜ å°„åˆ° grid åæ ‡ (æµ®ç‚¹æ•°)
            const gx = ((x + pSize/2) / pSize) * cols;
            const gz = ((z + pSize/2) / pSize) * cols;
            
            // è¾¹ç•Œ
            if (gx < 0 || gx >= cols - 1 || gz < 0 || gz >= cols - 1) return 0;

            const ix = Math.floor(gx);
            const iz = Math.floor(gz);
            const fx = gx - ix;
            const fz = gz - iz;
            
            const idx = iz * cols + ix;
            const h00 = app.buffers.current[idx];
            const h10 = app.buffers.current[idx + 1];
            const h01 = app.buffers.current[idx + cols];
            const h11 = app.buffers.current[idx + cols + 1];

            // åŒçº¿æ€§æ’å€¼
            const h0 = h00 * (1 - fx) + h10 * fx;
            const h1 = h01 * (1 - fx) + h11 * fx;
            return h0 * (1 - fz) + h1 * fz;
        }

        function updateFloatingItems() {
            const delta = 0.5; // æ¨¡æ‹Ÿæ­¥é•¿

            for (let i = 0; i < app.floatingItems.length; i++) {
                const item = app.floatingItems[i];
                const mesh = item.mesh;

                // 1. è®¡ç®—å‘¨å›´é«˜åº¦ï¼Œè·å¾—æ¢¯åº¦ (Gradient)
                // é‡‡æ ·ç‚¹é—´è·
                const offset = 1.0; 
                const hL = getWaterHeightAt(mesh.position.x - offset, mesh.position.z);
                const hR = getWaterHeightAt(mesh.position.x + offset, mesh.position.z);
                const hU = getWaterHeightAt(mesh.position.x, mesh.position.z - offset);
                const hD = getWaterHeightAt(mesh.position.x, mesh.position.z + offset);
                const hCenter = getWaterHeightAt(mesh.position.x, mesh.position.z);

                // 2. å†²æµªæ•ˆåº” (Surfing Effect)
                // å¦‚æœå·¦è¾¹é«˜å³è¾¹ä½ï¼Œæ°´ä¼šå¾€å³æ¨ç‰©ä½“
                // åŠ›åº¦ç³»æ•°
                const slideFactor = 0.15; 
                const forceX = (hL - hR) * slideFactor;
                const forceZ = (hU - hD) * slideFactor;

                // åº”ç”¨æ¨åŠ›åˆ°é€Ÿåº¦
                item.velocity.x += forceX;
                item.velocity.z += forceZ;

                // 3. é˜»å°¼ (æ°´é˜»åŠ›)
                item.velocity.multiplyScalar(0.92);

                // 4. æ›´æ–°ä½ç½®
                mesh.position.x += item.velocity.x;
                mesh.position.z += item.velocity.z;

                // 5. é«˜åº¦è·Ÿéš (ç´§è´´æ°´é¢)
                // é‡æ–°è·å–æ–°ä½ç½®çš„é«˜åº¦
                const newHeight = getWaterHeightAt(mesh.position.x, mesh.position.z);
                mesh.position.y = newHeight + 0.1; // 0.1 æµ®åŠ›åç§»

                // 6. å§¿æ€è·Ÿéš (å€¾æ–œ)
                // ç®€å•æ³•çº¿ä¼°ç®—ï¼šXè½´æ—‹è½¬å–å†³äºZè½´æ–¹å‘çš„æ–œç‡ï¼ŒZè½´æ—‹è½¬å–å†³äºXè½´æ–¹å‘æ–œç‡
                const slopeX = (hL - hR) / (offset * 2);
                const slopeZ = (hU - hD) / (offset * 2);

                // å¹³æ»‘æ—‹è½¬è¿‡æ¸¡
                mesh.rotation.z = mesh.rotation.z * 0.8 + slopeX * 0.2; // ç»•Zè½´è½¬å¯¹åº”Xæ–œç‡
                mesh.rotation.x = mesh.rotation.x * 0.8 - slopeZ * 0.2; // ç»•Xè½´è½¬å¯¹åº”Zæ–œç‡
                
                // åŠ ä¸Šä¸€ç‚¹ç‚¹éšæœºè‡ªè½¬ï¼Œæ¨¡æ‹Ÿæ°´æµæ‰°åŠ¨
                mesh.rotation.y += 0.01;
            }
        }

        function createSplash(pos) {
            const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const mat = new THREE.MeshBasicMaterial({ color: 0xaaccff, transparent: true, opacity: 0.6 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.position.y = Math.random() * 0.5 + 0.2;
            const vel = new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.6+0.2, (Math.random()-0.5)*0.5);
            app.scene.add(mesh);
            app.particles.push({ mesh, vel, life: 1.0 });
        }

        function updateParticles() {
            for (let i = app.particles.length - 1; i >= 0; i--) {
                let p = app.particles[i];
                p.vel.y -= 0.04;
                p.mesh.position.add(p.vel);
                p.life -= 0.04;
                p.mesh.rotation.x += 0.2;
                p.mesh.scale.setScalar(p.life);
                if (p.life <= 0 || p.mesh.position.y < -5) {
                    app.scene.remove(p.mesh);
                    if(p.mesh.geometry) p.mesh.geometry.dispose();
                    if(p.mesh.material) p.mesh.material.dispose();
                    app.particles.splice(i, 1);
                }
            }
        }

        function updateWater() {
            const cols = SYSTEM.gridSize;
            const count = cols * cols;
            for (let i = 1; i < cols - 1; i++) {
                for (let j = 1; j < cols - 1; j++) {
                    const idx = j * cols + i;
                    const val = (
                        app.buffers.previous[idx-1] + app.buffers.previous[idx+1] +
                        app.buffers.previous[idx-cols] + app.buffers.previous[idx+cols]
                    ) / 2 - app.buffers.current[idx];
                    app.buffers.current[idx] = val * SYSTEM.damping;
                }
            }
            const positions = app.mesh.geometry.attributes.position.array;
            for (let i = 0; i < count; i++) positions[i*3+2] = app.buffers.current[i];
            app.mesh.geometry.attributes.position.needsUpdate = true;
            app.mesh.geometry.computeVertexNormals();

            let temp = app.buffers.previous;
            app.buffers.previous = app.buffers.current;
            app.buffers.current = temp;
        }

        function animate() {
            app.animationId = requestAnimationFrame(animate);
            updateWater();
            updateParticles();
            updateFloatingItems();
            if(app.renderer && app.scene && app.camera) {
                app.renderer.render(app.scene, app.camera);
            }
        }
    </script>
</body>
</html>

